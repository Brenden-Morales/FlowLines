<!DOCTYPE html>
<html lang="en" style="width:100%;height:100%;padding:0px;margin:0px">
<head>
    <meta charset="UTF-8">
    <title>Leaflet Test</title>
</head>
<body style="width:100%;height:100%;padding:0px;margin:0px">
    <div id="map" style="position:absolute;top:0px;left:0px;z-index:1;width:100%;height:100%;padding:0px;margin:0px;"></div>
</body>
<link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet/v0.7.7/leaflet.css" />
<script src="leaflet-src.js"></script>
<script src="../libs/Three.js"></script>
<script src="TextureRenderer.js"></script>
<script src="FlowTexture.js"></script>

<script id="passThroughVertex" type="x-shader/x-vertex">
    void main()	{
        gl_Position = vec4( position, 1.0 );
    }
</script>

<script id="passThroughFragment" type="x-shader/x-fragment">
    uniform vec2 resolution;
    uniform sampler2D texture;
    void main(){
        vec2 pos = gl_FragCoord.xy / resolution;
        vec4 color = texture2D(texture,pos);
        gl_FragColor = color;
    }
</script>

<script id="flowMapFragment" type="x-shader/x-fragment">
    uniform sampler2D segments;

    //http://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment
    float getDistanceToLine(vec2 v,vec2 w,vec2 p)
    {
        //Return minimum distance between line segment vw and point p
        float l2 = pow(distance(v, w),2.0);  // i.e. |w-v|^2 -  avoid a sqrt
        if (l2 == 0.0) return distance(p, v);   // v == w case
        // Consider the line extending the segment, parameterized as v + t (w - v).
        // We find projection of point p onto the line.
        // It falls where t = [(p-v) . (w-v)] / |w-v|^2
        float t = dot(p - v, w - v) / l2;
        if (t < 0.0) return distance(p, v);       // Beyond the 'v' end of the segment
        else if (t > 1.0) return distance(p, w);  // Beyond the 'w' end of the segment
        vec2 projection = v + t * (w - v);  // Projection falls on the segment
        return distance(p, projection);
    }

    //get the directional color,
    //red is x, green is y
    vec4 getLineColor(vec2 point1, vec2 point2)
    {
        return vec4(normalize(point2 - point1),0.0,1.0);
    }

    void main(){
        vec4 pixelColor = vec4(0.0,0.0,0.0,0.0);

        bool inBounds = false;
        //loop through segments
        const float delta = 1.0 / 32.0;
        for(float currentY = 0.0; currentY < 1.0; currentY += delta){
            for(float currentX = delta; currentX < 1.0; currentX += delta * 2.0){
                vec4 currentVertex = texture2D(segments,vec2(currentX,currentY));
                vec4 previousVertex = texture2D(segments,vec2(currentX - delta,currentY));
                if(currentVertex.a == 1.0 && previousVertex.a == 1.0){
                    float distanceToLine = getDistanceToLine(previousVertex.xy,currentVertex.xy,gl_FragCoord.xy);
                    inBounds = distanceToLine < 2.5;
                    if(!inBounds)continue;
                    vec4 lineColor = getLineColor(previousVertex.xy,currentVertex.xy);
                    pixelColor += vec4(lineColor * float(inBounds));
                    if(inBounds)break;
                }
            }
            if(inBounds)break;
        }

        vec2 point1 = vec2(100.0,100.0);
        vec2 point2 = vec2(500.0,500.0);

        //get the color of the line
        vec4 lineColor = getLineColor(point1,point2);

        //get the distance for this pixel to the line
        float distanceToLine = getDistanceToLine(point1,point2,gl_FragCoord.xy);

        //check to see if this pixel is within the bounds of the line
        inBounds = distanceToLine < 5.0;

        gl_FragColor = vec4(lineColor * float(inBounds));
        gl_FragColor = vec4(normalize(pixelColor.xyz),pixelColor.w);
    }
</script>

<script>

    var makeUrl = function(bounds){
        var bbox =  "(" + bounds.getSouth() + "," + bounds.getWest() + "," + bounds.getNorth() + "," + bounds.getEast() + ");";
        var steps = [
            '[out:json];',
            'way',
            '["highway"~"trunk|primary|secondary|residential|service|unclassified"]',
            '["oneway"="yes"]',
            '["area"!~"."]',
            bbox,
            '(._;>;);',
            'out;'
        ];
        var url = 'http://overpass.osm.rambler.ru/cgi/interpreter?data=\n[out:json];\nway\n["highway"~"trunk|primary|secondary|residential|service|unclassified"]\n["oneway"="yes"]\n["area"!~"."]\n' + bbox + '\n(._;>;);\nout;';
        return "http://overpass.osm.rambler.ru/cgi/interpreter?data=" + steps.join("");
    };

    var map = L.map('map').setView([40.757081, -73.984365], 18);
    var canvasImageLayer = L.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token={accessToken}', {
        attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery Â© <a href="http://mapbox.com">Mapbox</a>',
        maxZoom: 18,
        id: 'brendenmorales.o25eegf6',
        accessToken: 'pk.eyJ1IjoiYnJlbmRlbm1vcmFsZXMiLCJhIjoiY2lnZ3l4YzR1ODQ1eXZvbHVzNWV3MnNzaiJ9.5PTcNsA-WpPRADoUurkZTA'
    }).addTo(map);

    var canvasTiles = L.tileLayer.canvas({
        tileSize : 512
    }).addTo(map);

    canvasTiles.on("tileload",function(event){
        var tile = event.tile;

        if(map.getZoom() > 10){

            var nwPoint = L.latLng(map.unproject(tile._tilePoint.multiplyBy(512), map.getZoom()));
            var sePoint = L.latLng(map.unproject(tile._tilePoint.multiplyBy(512).add(new L.Point(512, 512)), map.getZoom()));
            var bounds = L.latLngBounds(L.latLng(sePoint.lat,nwPoint.lng), L.latLng(nwPoint.lat,sePoint.lng));
            var url = makeUrl(bounds);

            var doProjection = function(point) {
                var s = {
                    x : tile._tilePoint.x * 512,
                    y : tile._tilePoint.y * 512
                };
                var p = map.project({
                    lat : point[1],
                    lng : point[0]
                }, this.zoom);
                return {
                    x : Math.round(p.x - s.x),
                    y : Math.round(p.y - s.y)
                };
            };


            var request = new XMLHttpRequest();
            request.doProjection = doProjection.bind(this);
            request.tile = tile;
            request.open("GET",url);
            request.onload = function(event){
                var response = JSON.parse(this.responseText);
                var nodes = {};
                var ways = [];

                for(var i = 0; i < response.elements.length;i++){
                    var element = response.elements[i];
                    if(element.type === "node"){
                        nodes[element.id] = this.doProjection([element.lon,element.lat]);
                    }
                    else if (element.type === "way"){
                        ways.push(element.nodes.map(function(obj){return obj.toString()}));
                    }
                }

                for(var i = 0; i < ways.length; i ++){
                    var way = ways[i];
                    for(var j = 0; j < way.length; j ++){
                        way[j] = nodes[way[j]];
                    }
                }

                var ft = new FlowTexture({
                    canvas:this.tile,
                    lines : ways
                });
                ft.getTexture();

            };
            request.send();
        }
    });
</script>
</html>